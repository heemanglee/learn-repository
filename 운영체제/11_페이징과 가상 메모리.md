## 1. 프로세스의 주소 공간
![스크린샷 2025-01-19 오후 11 46 03](https://github.com/user-attachments/assets/4a8202ff-491c-4828-a90b-fe66ff02b23d)

프로세스의 주소 공간으로 사용되는 것은 논리 주소이다. 논리 주소는 모든 프로세스가 독립적으로 가지며 0번지부터 시작한다. 반면에 하드웨어 상의 메모리 주소는 물리 주소이다. 실제로 프로세스는 물리 주소에 저장되지만, 프로세스마다 물리 주소를 기억하는 것은 어렵기 때문에 논리 주소로 표현한다. 
- 논리 주소(Logical Address) : 프로그램이 사용하는 가상의 주소 공간
- 물리 주소(Physical Address) : 실제 메모리의 하드웨어 주소

프로세스가 논리 주소를 사용할지언정, 실제로는 MMU에 의해 논리 주소가 물리 주소로 변환되는 과정을 거친다. 
> - MMU(Memory Management Unit, 메모리 관리 장치) : CPU와 메모리 사이에 위치하여 논리 주소를 물리 주소로 매핑한다.

## 2. 연속 메모리 기법의 문제점
연속 메모리 기법이란 실행 중인 모든 프로그램을 물리 메모리에 적재하는 방법이다. 실행 중인 프로그램을 차례대로 물리 메모리에 적재하면 될 것이다. 그러나 이 방법은 (1)외부 단편화 문제, (2)실제 메모리보다 큰 프로그램을 실행할 수 없는 문제를 야기한다.

(2)번의 경우 시스템의 메모리는 4GB인데 프로그램의 크기가 5GB인 경우 실행할 수 없다.

### 2-1. 외부 단편화
![스크린샷 2025-01-19 오후 11 50 02](https://github.com/user-attachments/assets/856a33c8-808a-4166-a427-7f6f1f9440f6)

외부 단편화는 연속 메모리 기법에서 발생하는 문제이다. 실행하기 위한 프로그램을 메모리로 스왑인하고, 종료된 프로그램을 보조 기억 장치로 스왑아웃하는 과정에서 사용되지 않는 메모리 공간이 발생한다. 
사진처럼 메모리 빈 공간으로 30MB, 20MB가 있을 때, 실행할 프로그램의 크기가 50MB라면 물리 메모리에 적재할 수 없다. 빈 공간들을 합치면 50MB가 되겠지만, 프로그램을 쪼개어 메모리에 적재할 수 없기 때문이다.
> - 스왑인(Swap-In) : 보조 기억 장치 -> 메모리로 프로그램을 적재한다.
> - 스왑아웃(Swap-Out) : 메모리 -> 보조 기억 장치로 프로그램을 내보낸다.
> - 스왑인, 스왑아웃 과정에서 프로그램은 기존의 물리 메모리 주소가 아닌 다른 주소에 적재된다.

## 3. 가상 메모리 기법을 통해 외부 단편화를 해결한다.
가상 메모리 기법이란 프로그램을 실행하는 데 필요한 부분만 메모리에 적재하여 시스템의 메모리 크기보다 큰 프로그램을 실행할 수 있도록 한다. 프로그램을 실행하는 데 필요한 부분은 메모리에 적재하고, 필요하지 않은 부분은 보조 기억 장치에 저장한다. 가상 메모리 기법으로 (1)페이징 기법, (2)세그먼테이션 기법이 존재한다. 본 글에서는 페이징 기법에 대해 설명한다.

### 3-1. 페이징 기법
![스크린샷 2025-01-20 오전 12 06 30](https://github.com/user-attachments/assets/f736fd27-96ad-4400-9dcf-cc6431569c93)

페이징 기법이란 프로세스의 논리 주소 공간을 일관된 크기의 페이지로 나누어 메모리에 적재하는 방법이다. 물리 주소 공간도 페이지 크기와 동일하게 프레임 단위로 나눈다. 페이지 크기와 프레임 크기가 동일하므로, 분할된 페이지들을 불연속적으로 물리 메모리에 적재할 수 있다. 

페이징 기법은 연속 메모리 공간에서 발생한 (1)외부 단편화, (2)시스템의 메모리 크기보다 큰 프로그램을 실행할 수 없는 문제를 해결한다. (1)번과 (2)번 문제가 발생한 이유는 실행할 프로그램 자체를 물리 메모리에 적재하기 때문에 남아있는 물리 메모리 공간보다 큰 프로그램을 적재할 수 없었기 때문이다. 이 문제들을 해결하기 위해 페이징 기법을 사용하여 프로그램 실행에 필요한 페이지들을 물리 메모리에 불연속적으로 적재하여 해결할 수 있다.

### 3-2. 페이지를 불연속적으로 물리 메모리에 적재하므로 페이지 테이블이 사용된다.
![스크린샷 2025-01-20 오전 12 10 29](https://github.com/user-attachments/assets/36b6a05c-47bb-477f-8fda-af8da5ac94de)

CPU는 프로세스를 실행하기 위해서 페이지가 적재된 물리 메모리 주소를 알아야한다. 페이징 기법에서는 프로세스의 페이지들이 물리 메모리에 불연속적으로 적재되기 때문에 CPU가 프로세스 실행에 필요한 페이지가 적재된 프레임 위치를 알아야 한다.

페이지 테이블에는 (페이지 번호, 프레임 번호) 데이터를 저장한다. CPU는 페이지 테이블을 참고하여 페이지가 적재된 프레임 위치를 알아내어 실행할 수 있다. 프로세스마다 페이지 테이블을 가지고 있으며 물리 메모리에 적재된다.

페이지 테이블은 (페이지 번호, 프레임 번호) 말고도 유효 비트, 보호 비트, 참조 비트, 수정 비트 정보를 가지고 있다.
- 유효 비트 : 페이지가 메모리에 적재된 상태인지를 나타낸다.
  - 1 : 메모리에 적재된 상태
  - 0 : 보조 기억 장치에 저장된 상태
- 보호 비트 : 페이지의 읽기/수정/실행 가능 여부를 나타낸다.
  - rwx : 000/ 001/ 011/ 111/ 101/ ...
- 참조 비트 : 페이지가 메모리에 적재된 이후로 CPU가 참조한 적이 있는지를 나타낸다.
  - 1 : 참조된 적이 있다.
  - 0 : 참조된 적이 없다.
- 수정 비트 : 페이지가 메모리에 적재된 이후로 수정된 적이 있는지를 나타낸다.
  - 1 : 수정된 적이 있다.
  - 0 : 수정된 적이 없다.

이 비트 중에서 유효 비트에 대해서 알아보자. CPU는 프로세스를 실행하기 위해 페이지가 적재된 프레임 위치를 알아야 한다. 그렇다면 전제 조건으로 페이지가 메모리에 적재된 상태여야 한다. 만약 CPU가 메모리에 적재되지 않은 페이지에 접근하려고 시도하면 페이지 폴트(Page Fault) 예외가 발생한다. (= 유효 비트가 0인 페이지에 접근한 것) 

페이지 폴트가 발생하면 페이지 폴트 처리 루틴이 실행되어, 보조 기억 장치에 있는 페이지가 메모리에 적재된다. 동시에 해당 페이지의 유효 비트는 1로 수정된다. 다만, 페이지 폴트가 발생하면 디스크에서 페이지를 읽어와야 하는데 디스크 I/O는 느린 작업이므로 시스템 성능에 영향을 미친다.

### 3-3. 페이징 주소 체계에서는 변위(Offset)를 사용한다.
![스크린샷 2025-01-20 오전 12 57 43](https://github.com/user-attachments/assets/4bda3643-4b28-4fcc-89ed-f1171744c6ac)

페이지는 프로세스의 논리 주소 여러 개를 포함한다. CPU는 물리 메모리에 적재된 특정 데이터에 접근하기 위해서는 프레임 번호뿐만 아니라 변위(OffSet)을 사용해야 한다.
> - 변위(Offset) : 페이지(프레임)에 포함된 여러 논리 주소(물리 주소) 중에서 접근할 위치

CPU는 페이지 테이블을 통해 (페이지 번호, 변위) -> (프레임 번호, 변위로) 매핑하는 과정을 거친다. 페이지 번호는 페이지 테이블에 저장된 프레임 번호로 변환되고, 변위는 그대로 사용된다. CPU는 프레임이 적재된 물리 메모리 시작 주소로 이동 및 변위만큼 이동하여 실제 데이터에 접근한다.

## 4. 페이징 기법은 외부 단편화를 해결했지만, 내부 단편화가 발생한다.
![스크린샷 2025-01-20 오전 12 17 32](https://github.com/user-attachments/assets/14b8045c-569c-4aa9-89e3-d92f94d5f78b)

페이징 기법은 프로세스의 논리 주소 공간을 일정한 크기의 페이지로 분할하는 것이었다. 그러나 일정한 크기로 나누기 때문에 내부 단편화가 발생한다. 내부 단편화란 프로세스의 논리 주소 공간이 페이지 크기에 딱 맞춰 분할되는 것이 아니므로, 마지막 페이지는 비어있는 공간이 발생할 수 있다. 
- 프로세스의 크기 : 50KB
- 페이지 크기 : 9KB
프로세스의 논리 주소 공간이 6개의 페이지로 분할되는데, 마지막 페이지는 5KB가 남는다. 페이지는 프레임에 적재되기 때문에, 사용되지 않는 물리 메모리 공간이 생기게 된다.

## 5. 프로세스의 페이지 테이블 위치는 PTBR(Page Table Base Register)에 저장된다.
![스크린샷 2025-01-20 오전 12 24 32](https://github.com/user-attachments/assets/43223234-d4dd-46a8-9e6f-9203985ee055)

모든 프로세스는 자신만의 페이지 테이블을 갖는다. 이 페이지 테이블은 물리 메모리에 저장된다. CPU는 프로세스를 실행할 때 페이지가 적재된 프레임 위치를 알아내기 위해 페이지 테이블에 접근한다. 그렇다면 CPU는 해당 프로세스의 페이지 테이블이 위치한 물리 메모리 주소를 알아야 한다.

PTBR(Page Table Base Register)에는 모든 프로세스의 페이지 테이블이 저장된 물리 메모리 주소가 저장되어 있다. CPU는 프로세스를 실행하기 위해 PTBR에 먼저 접근한 후에 페이지 테이블에 접근하게 된다.

## 6. TLB(Translation Look-aside Buffer)룰 사용하여 CPU가 물리 메모리에 접근하는 횟수를 줄일 수 있다.
앞선 설명을 통해 CPU가 프로세스를 실행하기 위해서는 물리 메모리에 두 번 접근해야 하는 것을 알았다.
1. 페이지 테이블이 저장된 물리 메모리 주소를 알아내기 위해 PTBR에 접근한다.
2. 페이지 테이블을 참고하여 페이지가 적재된 프레임 위치를 알아내어, 프레임에 접근한다.

CPU가 물리 메모리에 접근하는 것은 느린 작업이므로, 프로세스를 실행할 때마다 2번씩 접근하는 것은 비효율적이다. 이를 해결하기 위해 TLB(Translation Look-aside Buffer)룰 사용하여 1회만으로 프레임에 접근할 수 있도록 한다.

TLB는 페이지 테이블 정보를 캐싱한 것으로, 자주 사용되는 페이지의 (페이지 번호, 프레임 번호)를 TLB에 저장한다. CPU는 프로세스를 실행할 때 TLB에 저장된 정보를 기반으로 바로 프레임에 접근할 수 있다. 자주 사용된다의 판단 근거는 참조 지역성에 기반을 둔다.
> - 참조 지역성 : 최근에 접근한 데이터를 다시 한 번 접근할 가능성이 높다.

![스크린샷 2025-01-20 오전 12 36 11](https://github.com/user-attachments/assets/39d97fab-39de-405b-a48e-65c0021a173d)

사진을 보면 CPU가 프로세스를 실행하기 위해 TLB에 먼저 접근한 후에 물리 메모리에 접근하는 것을 알 수 있다. CPU가 TLB에 접근했을 때 실행할 페이지의 정보가 저장되어 있다면 TLB 히트이고, 없다면 TLB 미스이다.
- TLB 히트 : TLB에 저장된 정보를 기반으로 바로 프레임에 접근한다. 따라서 CPU가 물리 메모리에 접근하는 횟수는 1번이다.
- TLB 미스 : TLB에 저장된 정보가 없으므로, 페이지 테이블이 저장된 물리 메모리에 접근한 후, 이 정보를 기반으로 프레임에 접근한다. 따라서 CPU가 물리 메모리에 접근하는 횟수는 2번이다.
