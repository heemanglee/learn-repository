## 1. 스케줄링(Scheduling)
스케줄링이란 한정적인 CPU를 효율적으로 사용하도록, 대기 중인 프로세스들에게 적합한 방법으로 CPU를 할당하는 방법이다.

스케줄링에는 비선점 스케줄링과 선점 스케줄링이 존재한다.
- 비선점 스케줄링 : 프로세스가 사용 중인 CPU를 빼았을 수 없다.
  - 프로세스가 직접 CPU를 반납해야 한다. (입출력 I/O, Time Out)
- 선점 스케줄링 : 프로세스가 사용 중인 CPU를 빼았을 수 있다.

## 2. 비선점 스케줄링(Non-Preemptive)
비선점 스케줄링이란 CPU를 할당받은 프로세스가 직접 CPU를 반납하지 않는 이상, Ready Queue에 있는 프로세스가 CPU를 할당받지 못한다. 
직접 CPU를 반납하는 경우는 입출력 I/O에 의해 Blocked 상태가 되거나, Terminated 상태가 되면서 CPU를 반납하는 것이다.
비선점 스케줄링의 대표적인 알고리즘으로 FCFS, SJF가 있다.

### FCFS(First-Come, First-Out) 알고리즘
FCFS는 FIFO 구조의 Queue를 사용하여 CPU를 프로세스에게 할당하는 방법이다. 따라서 Ready Queue에 들어온 프로세스부터 CPU를 사용할 수 있다.
이 알고리즘은 Queue에 먼저 들어온 프로세스부터 CPU를 할당하면 되므로 구현이 간단하다는 장점이 있다. 그러나 FIFO 구조가 오히려 평균 대기 시간을 증가시킨다는 단점이 존재한다. 

<img width="748" alt="FCFS 단점1" src="https://github.com/user-attachments/assets/36e94f72-e7ce-42b5-9ebc-1945cafb8c8d" /> <br />
그림을 보면 P1, P2, P3 순서대로 Ready Queue에 프로세스가 삽입된 상태이다. Queue는 FIFO 구조이므로 먼저 들어온 P1 프로세스부터 CPU가 할당되어 마지막으로 P3 프로세스가 할당받는다. 
P2, P3 프로세스는 P1에 비해 실행 시간이 매우 짧음에도 P1 프로세스가 CPU를 반납할 때까지 기다려야 한다. P2는 CPU를 사용하기 위해 24초를 기다려야 하고, P3는 27초를 기다려야 한다. 따라서 Queue에 담긴 모든 프로세스가 CPU를 할당받을 때까지의
평균 대기 시간이 매우 길다는 단점이 존재한다.
<br /> <br />

<img width="761" alt="FCFS 단점2" src="https://github.com/user-attachments/assets/3368aa97-4b39-48a8-8634-52428396e1aa" /> <br />
이번에는 반대로 P1, P2, P3 순서대로 실행 시간이 짧은 상황이다. P2는 CPU를 사용하기 위해 3초를 기다려야하고, P3는 7초를 기다려야 한다. 따라서 모든 프로세스가 CPU를 받기 까지 기다리는 평균 대기 시간은 고작 3.33초 이다.
<br /> <br />

- 장점 : FIFO 구조의 Queue를 사용하면되므로, 구현이 매우 간단하다.
- 단점
  - 실행 시간이 긴 프로세스가 먼저 도착하면 평균 대기 시간이 증가한다.
  - Queue에 먼저 삽입된 프로세스의 실행 시간이 매우 길다면, 나머지 프로세스들의 대기 시간이 증가하는 Convoy Effect(호위 효과)가 발생한다.

## SJF(Shortest Job First) 알고리즘
SJF 알고리즘은 우선순위 큐를 사용하여, 우선순위가 높은 프로세스에게 먼저 CPU를 할당하는 방법이다. Queue는 FIFO 구조로 먼저 도착한 프로세스부터 CPU를 할당받아야 하지만, SJF는 뒤늦게 도착한 프로세스의 우선순위가 높다면 해당 프로세스에게 먼저 CPU를 할당한다.
이는 FCFS의 평균 대기 시간이 길었던 단점을 극복할 수 있으나, 우선순위가 낮은 프로세스가 CPU를 오랫동안 할당받지 못하는 기아 현상(Starvation)이 발생한다.

<img width="588" alt="스크린샷 2025-01-18 오후 5 04 36" src="https://github.com/user-attachments/assets/41c1f9c8-938b-4a98-8fed-9d29e809d421" /> <br />
실행 시간이 작을수록 우선순위가 높은 상황이다. 사진에서는 P1, P2, P3 순서대로 Queue에 도착했지만, 실행시간이 작은 P3, P2, P1 순서로 바뀐 것을 알 수 있다.
<br /> <br />

- 장점 : 프로세스들의 평균 대기 시간을 최소화할 수 있다
- 단점 : 우선순위가 낮은 프로세스가 오랫동안 CPU를 할당받지 못하는 기아 현상(Starvation)이 발생한다.

## 3. 선점 스케줄링(Preemptive Scheduling)
선점 스케줄링이란 프로세스가 사용 중인 CPU를 강제로 회수할 수 있는 방법이다. 뒤늦게 도착한 프로세스가 급하게 처리할 작업이 있다면, CPU를 사용 중인 프로세스로부터 CPU를 빼앗아 제공할 수 있다.

선점 스케줄링의 대표적인 방법으로 라운드 로빈, SRT 알고리즘이 존재한다.

### 라운드 로빈(Round Robin) 알고리즘
라운드 로빈 알고리즘은 FCFS 처럼 FIFO 구조의 Queue를 사용한다. 먼저 도착한 프로세스부터 CPU를 할당하되, CPU를 사용할 수 있는 Time Quantum을 설정하여 특정 프로세스가 CPU를 독점하지 못하도록 한다. 


<img width="1121" alt="스크린샷 2025-01-18 오후 5 16 29" src="https://github.com/user-attachments/assets/b0b1a698-4e86-4ddb-8641-4c59c3127704" /> <br />
Time Quantum이 4초이고, P1, P2, P3 순서대로 도착한 상태이다. 라운드 로빈은 FCFS와 동일하게 먼저 도착한 프로세스부터 CPU를 할당하되, Time Quantum 동안만 사용할 수 있도록 한다. 따라서 CPU 사용 시간이 24초인 P1은 4초동안 CPU를 사용하고 Queue에 삽입된다. 다음으로 P2, P3 프로세스는 Time Quantum 보다 적은 시간을 CPU를 사용한다. 이후에 Queue에는 P1 프로스세만 있으므로 CPU를 독점하여 사용할 수 있다.
<br /> <br />

- 장점
  - 기아 현상을 방지할 수 있다.
  - 모든 프로세스가 동일하게 CPU를 할당받는다.
  - Time Quantum이 짧을수록 프로세스들이 CPU를 할당받는 주기가 짧아진다. 따라서 사용자는 빠른 응답을 받을 수 있다.
- 단점
  - Time Quantum이 크면 FCFS 알고리즘과 비슷하게 동작하게 된다.
  - Time Quantum이 작다면 컨텍스트 스위칭이 빈번하게 일어나므로 오버헤드가 발생한다.

### SRT(Shortest Remaining Time) 알고리즘
SRT 알고리즘은 남은 실행 시간이 가장 짧은 프로세스에게 CPU를 먼저 할당하는 방식이다. 따라서 프로세스 A가 CPU를 사용 중이더라도, 뒤늦게 도착한 프로세스 B의 실행 시간이 더 짧다면 프로세스 A의 CPU를 프로세스 B에게 전달한다. 

<img width="347" alt="스크린샷 2025-01-18 오후 5 34 13" src="https://github.com/user-attachments/assets/1006a281-2000-4f1c-b74c-0717df7270a1" /> <br />
P1이 가장 먼저 도착했으므로 CPU를 할당받게 된다. 1초가 지났을 때 P2가 도착하게 되는데, P2의 실행 시간이 더 짧으므로(P1: 7초, P2: 4초) P1이 사용 중인 CPU를 빼앗아 P2에게 제공한다. 이때 P1은 Queue에 삽입된다. 이러한 선점 방식은 나머지 프로세스에게 모두 적용된다.
<br /> <br />

- 장점
  - 남은 실행 시간이 짧은 프로세스부터 실행되므로 평균 대기 시간이 작다.
- 단점
  - 남은 실행 시간이 긴 프로세스가 오랫동안 CPU를 할당받지 못하는 기아 현상이 발생한다.
  - CPU를 사용하다가도, 남은 실행 시간이 작은 프로세스에게 CPU를 빼앗기므로 컨텍스트 스위칭이 빈번하게 일어난다.

