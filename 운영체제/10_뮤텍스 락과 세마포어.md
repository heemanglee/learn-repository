## 1. 프로세스 동기화
여러 프로세스가 공유 자원에 동시에 접근했을 때 예상하지 못한 결과를 초래할 수 있다. 따라서 공유 자원에는 여러 프로세스가 동시에 접근하지 못하도록 제어하는 방법이 필요하다. 이 방법에는 뮤텍스 락(Mutex Lock)과 세마포어(Semaphore)가 있다.

(본 글에서는 프로세스로 설명하지만, 스레드에도 동일하게 적용된다. 즉, 스레드도 동기화가 필요하다.)

## 2. 뮤텍스 락(Mutex Lock)
뮤텍스 락은 Lock을 사용하여 임계 구역(Critical Section)을 보호하는 방법이다. 뮤텍스 락은 Lock을 가진 프로세스만이 임계 구역에 접근할 수 있고, 작업을 완료했다면 Lock을 반납하는 방식이다. 뮤텍스 락이 동작하는 방법은 다음과 같다.
> - 임계 구역이란 공유 자원에 접근하는 코드 영역을 의미한다.
1. 프로세스 A는 자원 A를 사용하기 위해 Lock 획득을 시도한다.
2. 자원 A를 사용하는 프로세스가 없으므로 프로세스 A는 Lock을 획득한다.
3. Lock을 획득한 프로세스 A는 임계 구역에 진입하여 자원 A를 사용한다.
4. 프로세스 B가 자원 A를 사용하기 위해 Lock 획득을 시도한다.
5. 이미 프로세스 A가 자원 A의 Lock을 획득했으므로, 프로세스 B는 Lock을 얻지 못하고 대기한다.
6. 프로세스 A는 작업을 완료하고, 임계 구역을 벗어나면서 Lock을 반납한다.
7. 대기 중이던 프로세스 B는 Lock을 획득하고 임계 구역에 진입한다.
8. 프로세스 B의 나머지 과정은 프로세스 A와 동일하다.

이처럼 Lock을 사용하여 임계 구역을 보호하기 때문에, 상호 배제(Mutual Exclusion)를 통한 경쟁 상태(Race Condition)가 발생하지 않도록 한다.
> - 상호 배제(Mutual Exclusion) : 여러 프로세스가 존재할 때, 공유 자원은 하나의 프로세스만 사용할 수 있고, 다른 프로세스들은 대기한다.
> - 경쟁 상태(Race Condition)란 여러 프로세스가 동시에 공유 자원에 접근했을 때, 프로세스 실행 순서에 따라 결과가 달라지는 문제

## 3. 세마포어(Semaphore)
세마포어는 카운트 변수를 사용하여 임계 구역에 여러 프로세스가 동시에 접근하지 못하도록 보호한다. 뮤텍스 락은 Lock을 사용하여 하나의 프로세스만 접근 가능했다면, 세마포어는 카운트 변수만큼 여러 프로세스가 동시에 접근하는 것을 허용한다. 단, 세마포어도 카운트 변수가 0이 되면 프로세스는 임계 구역에 접근하지 못하고 대기 상태가 된다.
- 이진 세마포어(Binary Semaphore) : 카운트 변수를 1로 설정하여, 하나의 프로세스만 임계 구역에 접근할 수 있도록 한다. (= 뮤텍스 락과 비슷하다.)
- 카운팅 세마포어(Counting, Semaphore) : 카운트 변수를 S로 설정하여, S개의 프로세스가 동시에 임계 구역에 접근할 수 있도록 한다.

세마포어는 P(Wait), V(Signal) 연산을 통해 임계 구역을 제어한다.
- P(Wait) : 임계 구역에 접근할 때 호출하는 코드이다.
  - 카운트 변수에 따라 임계 구역 진입 여부가 결정된다.
  - 카운트 변수 0 : 임계 구역에 진입하지 못하고 대기 상태가 된다.
  - 카운트 변수 >= 1 : 카운트 변수를 1 감소시키고, 임계 구역에 진입한다.
- V(Signla) : 임계 구역을 벗어날 때 호출하는 코드
  - 임계 구역을 벗어나면서 카운트 변수 1 증가시킨다.
  - 대기 중이던 프로세스는 임계 구역에 진입할 수 있게 된다.

- P(Wait) 연산
```java
P(S) {
  while(S <= 0); // 임계 구역에 진입하지 못하고 대기 상태가 된다.
  S--; // 임계 구역에 진입하면서 카운트 변수 1 감소
}
```
- V(Signal) 연산
```java
V(S) {
  // 임계 구역을 벗어나면서 카운트 변수를 1 증가시킨다.
  // 임계 구역에 진입하지 못하고 대기 중이던 프로세스가 진입할 수 있게 된다.
  S++; 
}
```

## 4. 바쁜 대기(Busy Wait)로 구현한 P(Wait) 연산은 비효율적이다.
세마포어에서 P 연산을 구현할 때 바쁜 대기(Busy Wait)로 구현할 수 있다. 
> - 바쁜 대기(Busy Wait) : CPU를 계속 사용하면서 특정 조건을 만족할 때까지 반복하여 확인하는 방법이다.

아래의 경우 바쁜 대기로 구현된 P 연산인데, `while(S <= 0)` 이 과정에서 CPU를 계속 사용하며 카운트 변수(S) 값을 확인한다.  
```java
P(S) {
  while(S <= 0); // 임계 구역에 진입하지 못하고 대기 상태가 된다.
  S--; // 임계 구역에 진입하면서 카운트 변수 1 감소
}
```

바쁜 대기의 특징
- 장점
  - 구현이 매우 간단하다.
  - CPU를 반납하지 않기 때문에 컨텍스트 스위칭(Context Switching)이 발생하지 않는다.
  - 자원이 사용 가능한 상태가 될 때 빠르게 반응할 수 있다. 왜냐하면 CPU를 계속 사용하면서 특정 조건을 만족하는지 반복하여 확인하기 때문이다.
- 단점
  - CPU를 반납하지 않으므로 다른 프로세스가 CPU를 사용할 수 없어 매우 비효율적이다.
  - 다른 프로세스의 작업 시간이 길어질수록, 단순히 조건 확인하는 데 사용되는 CPU 사용 시간이 길어진다.

임계 구역에 접근하지 못하고 대기 상태인 것 != 프로세스 상태가 대기(Ready) 상태인 것
- 전자는 Running 상태에서 CPU를 계속 사용한다.
- 후자는 CPU를 반납하고 스케줄링을 기다린다.

## 5. 바쁜 대기가 아닌, Block/WakeUp 방식으로 구현할 수 있다.
바쁜 대기의 문제점이 단순 특정 조건을 확인하는데 CPU를 낭비하는 것이었다. Block/Wait 방식을 사용하면 임계 구역에 진입하지 못했을 때 CPU를 반납하고 세마포어 대기 큐(Wait Queue)에 삽입되게 할 수 있다. 또한, 임계 구역에 접근할 수 있는 상황이 된다면세마포어 대기 큐에 있는 프로세스를 깨울 수 있다.
> - 블로킹(Blocked) 상태 : 실행을 멈추고 대기하는 상태이다. 즉, Running 상태의 프로세스가 Blocked 상태가 되면서 CPU를 반납한다.
>   - 단, Blocked 상태의 프로세스는 Ready Queue에 삽입되는 것이 아니다. Ready Queue는 Ready 상태의 프로세스가 스케줄링을 기다리는 상태이다.

- P(Wait) 연산 
```java
P(S) {
  S--; // 임계 구역에 진입하기 전에 카운트 변수 1 감소
  if(S < 0) { // 카운트 변수 < 0이면 블로킹 상태가 된다.
    add this process to Wait Queue; // 대기 큐에 현재 프로세스 삽입
    sleep(); // 현재 프로세스를 블로킹 상태로 전환
  }
}
```
- V(Signal) 연산
```java
V(S) {
  S++; // 임계 구역을 벗어나면서 카운트 변수 1 증가
  if(S <= 0) { // 대기 중인 프로세스가 있을 때
    remove a process from Wait Queue; // 대기 큐에서 프로세스 제거
    wakeup(this process); // 해당 프로세스를 깨운다.
  }
}
```

Block/Wait 방식은 바쁜 대기와 달리 임계 구역에 진입하지 못하면 CPU를 반납하고 세마포어 대기 큐(Wait Queue)에서 대기한다. CPU를 다른 프로세스가 사용할 수 있도록 하므로 한정적인 CPU 자원을 효율적으로 사용할 수 있게 된다.
