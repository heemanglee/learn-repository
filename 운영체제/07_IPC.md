## 1. IPC(Inter Process Communication)이란?
프로세스 간에 데이터를 주고받는 행위는 기본적으로 불가능하다. 왜냐하면 프로세스마다 독립된 메모리 공간을 갖기 때문이다. 주소 공간이 다른 프로세스 간에 데이터를 주고받는다면 데이터 일관성 문제와 주소 충돌이 발생할 수 있다.
그러나 IPC(Inter Process Communication)를 사용한다면 프로세스 간에 통신이 가능해진다. IPC 방법으로 (1)공유 메모리, (2)메시지 전달, (3)파이프, (4)메시지 큐 방식이 존재한다.

### 공유 메모리
![image](https://github.com/user-attachments/assets/0235e7a9-c5dc-4a99-90c8-41c0619ace9e) <br />
공유 메모리란 데이터를 읽고 쓰기 위한 공간을 사용자 영역에 할당하는 방식이다. 데이터를 주고받을 새로운 공간을 할당할 때만 커널이 개입하고, 이후에는 사용자 영역에서 프로세스 간에 데이터를 주고받으므로 커널이 개입하지 않는다. 커널이 개입하지 않고 프로세스가 직접 데이터를 주고받으므로 속도가 빠르겠지만, 동시에 두 프로세스가 공유 메모리에 접근하면 데이터 일관성 문제가 생길 수 있다. 따라서 뮤텍스 락(Mutex Lock), 세마포어(Semaphore)와 같은 동기화 작업을 해야 한다. 

### 메시지 전달
![image](https://github.com/user-attachments/assets/aa79c893-caa8-499d-9049-315410ef10d3) <br />
메시지 전달이란 커널이 개입하여 프로세스 간에 데이터를 주고받는 방식이다. 공유 메모리와 달리 데이터를 주고받을 새로운 공간을 할당받지 않고, 커널을 통해서 주고 받는다. 프로세스 A가 커널에 데이터를 전달하면 프로세스 B는 커널에 저장된 데이터를 읽으면 된다. 프로세스가 커널을 호출하기 위해서는 시스템 콜(System Call)을 호출해야 하는데, 커널에 데이터를 전달할 때는 send()를 호출하고 커널로부터 데이터를 전달받을 때는 recv() 시스템 콜을 호출한다. 커널을 통해 데이터를 주고받기 때문에 속도가 느리지만, 커널 덕분에 데이터를 안전하게 주고받을 수 있다.

### 파이프
![image](https://github.com/user-attachments/assets/567ebbe2-0292-4227-8c3a-e627418f7beb) <br />
파이프 방식은 데이터를 주고받을 단방향 파이프를 생성하는 방식이다. 파이프 중에서도 (1)익명 파이프와 (2)네임드 파이프가 존재한다. 익명 파이프는 pipe() 시스템 콜로 생성하며, 부모-자식 관계에 있는 프로세스만 사용할 수 있는 파이프이다. 반면에 네임드 파이프는 mkfifo() 시스템 콜을 통해 생성하고, 독립적 관계에 있는 프로세스 간에 데이터를 주고받을 수 있는 파이프이다. 파이프는 단방향으로만 데이터를 주고받을 수 있기 때문에 양방향 통신이 필요하다면 파이프를 하나 더 생성해야 한다.
- 파이프는 반이중 통신이다. : 프로세스 A는 데이터를 전송만 할 수 있고, 프로세스 B는 데이터를 읽기만 가능하다.
- 전이중 통신을 사용하고 싶다면 파이프를 두 개 설치하면 되는데, 이를 구현하는 것은 복잡한 작업이다.
  - 1번 파이프 : 프로세스 A -> 프로세스 B
  - 2번 파이프 : 프로세스 B -> 프로세스 A

### 메시지 큐
![image](https://github.com/user-attachments/assets/5bacf4f9-63cf-46ed-918f-41900c9e5655) <br />
메시지 큐 방식은 데이터를 주고받기 위해 큐를 사용한다. 메시지 큐는 커널 메모리에 생성되어 시스템 콜을 통해 데이터를 주고받을 수 있다. 프로세스 A는 전달할 데이터는 msgsnd() 시스템 콜을 통해 큐에 전달하고, 프로세스 B는 msgrcv()를 통해 큐에 저장된 데이터를 읽는다. 큐는 FIFO(First-In, First-Out) 구조이므로, 큐에 먼저 전달된 데이터부터 수신할 수 있다. 다만, 데이터에 우선 순위를 설정하여 먼저 도착한 데이터보다 우선 순위가 높은 데이터를 먼저 읽도록 할 수도 있다. 메시지 큐는 비동기 방식으로 전달하기 때문에 프로세스 A는 큐에 메시지를 전달한 이후로 프로세스 B가 수신하였는지 고려하지 않는다. 즉, 프로세스 A가 메시지를 전달하는 것과 프로세스 B가 읽는 것은 독립적으로 실행된다. 큐의 공간은 한정적이기 때문에 큐의 공간이 가득찬 경우 프로세스 A는 메시지를 전달하지 못하고 대기 상태가 된다.

### 소켓(Socket)
소켓은 네트워크를 통해 프로세스 간에 통신하는 방법이다. 클라이언트와 서버가 소켓을 통해 연결을 맺고, 이 연결을 통해 데이터를 주고 받는다. 
소켓은 양방향 통신이 가능하므로, 클라이언트와 서버 둘 다 데이터를 주고 받을 수 있다.

![image](https://github.com/user-attachments/assets/ec0a96bf-6429-4b39-8489-77e115dbf2cd)

[클라이언트 소켓 연결 과정]
1. socket() 함수를 호출하여 서버와 데이터를 주고받을 소켓을 생성한다.
2. connect() 함수를 호출하여 서버의 (IP, Port)로 연결 요청을 보낸다.
3. 클라이언트 소켓과 서버 소켓이 연결되면 send(), recv()를 통해 데이터를 주고받는다.
4. close() 함수를 호출하여 소켓을 닫고 연결을 종료한다.

[서버 소켓 연결 과정]
1. socket() 함수를 호출하여 클라이언트의 요청을 기다리는 listen 상태의 소켓을 생성한다.
2. bind() 함수를 통해 서버의 IP와 Port를 listen 상태의 소켓에 바인딩한다.
3. listen() 함수를 호출하여 클라이언트의 연결 요청을 기다린다.
4. 클라이언트로부터 연결 요청이 들어오면, 서버는 accept() 함수를 호출하여 연결 요청을 수락한다. 단, 이때 1~3번에서 사용된 listen 상태의 소켓이 아닌, 연결을 위한 새로운 소켓을 생성한다.
  - listen 소켓은 클라이언트의 요청을 기다리는 소켓이다.
  - accept() 함수가 호출되면 클라이언트 소켓과 연결을 위한 서버 소켓을 새로 생성한다.
5. 클라이언트 소켓과 서버 소켓이 연결되면 send(), recv()를 통해 데이터를 주고받는다.
6. close() 함수를 호출하여 소켓을 닫고 연결을 종료한다.
