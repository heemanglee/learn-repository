## 1. PCB(Process Control Block)란?
<img width="648" alt="스크린샷 2025-01-17 오후 4 43 21" src="https://github.com/user-attachments/assets/47459080-71b6-4c01-9e6e-01bed36c2a4b" />

프로세스가 생성될 때마다 PCB도 같이 생성된다. 즉, 프로세스마다 PCB가 존재한다.

PCB는 프로세스의 metadata를 담고 있는 공간이다. PCB에 저장되는 데이터는 다음과 같다.
- PID(Process ID)
- 프로세스 상태(Created, Ready, Running, Blocked, Terminiated)
- 프로세스의 우선순위(스케줄링 우선순위)
- CPU Register
- CPU PC
- ...

## 2. Context Switching(문맥 교환)
<img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/59e18fc2-434e-4398-8d9f-40056757489f" />

Running 상태에 있던 프로세스가 CPU Time Quantum이 만료되어 타이머 인터럽트에 의해 Ready 상태가 되거나, 입출력 I/O에 의해 Blocked 상태가 될 때 사용하던 CPU를 반납한다. 이 CPU는 스케줄링에 의해 Ready Queue에서 대기 중인 프로세스에게 할당된다. 

CPU를 사용하는 프로세스가 바뀔 때 컨텍스트 스위칭이 발생한다. 컨텍스트 스위칭은 현재 프로세스의 작업 내용을 PCB에 저장하고, 다음으로 실행할 프로세스의 PCB 정보를 불러오는 과정이다. 프로세스의 작업 내용을 PCB에 저장하기 때문에, CPU를 반납하여 Ready Queue에 있던 프로세스가 다시 CPU를 할당받아 실행될 때 마지막으로 수행했던 작업을 이어서 진행할 수 있다.
(참고로 프로세스뿐만 아니라 스레드에서도 컨텍스트 스위칭이 발생한다.)

우리가 수많은 프로그램을 실행할 때 동시에 실행되는 것처럼 보이는 이유는 컨텍스트 스위칭이 일어나기 때문이다. CPU 자원은 한정적이지만 실행되는 프로그램은 매우 많다. 모든 프로그램이 실시간으로 동시에 실행되는 것처럼 보이는 이유는 컨텍스트 스위칭 속도가 매우 빠르기 때문이다.

그러나 컨텍스트 스위칭이 빈번히 일어나면 성능상 좋지 않다. 컨텍스트 스위칭이 발생하면 CPU 캐시 무효화가 발생하기 때문이다. CPU는 프로세스가 사용할 데이터를 메인 메모리(RAM)에서 받아오는데, 메인 메모리의 속도는 CPU보다 현저히 느리다. 
따라서 CPU는 내부에 캐시 메모리를 사용하여 매번 메인 메모리에서 데이터를 받아오지 않고, 프로세스가 반복적으로 사용하는 데이터는 CPU 캐시에 저장하여 빠르게 접근할 수 있도록 한다.
CPU 캐시에는 컨텍스트 스위칭이 발생하기 전의 프로세스가 자주 사용한 데이터가 담겨 있으므로, CPU를 새로 할당받은 프로세스가 해당 데이터에 접근할 수 없다. 따라서 이전 프로세스가 사용한 데이터는 CPU 캐시에서 지워야 한다.
새로운 프로세스는 CPU 캐시에 저장된 데이터가 없으므로 초반에 캐시 미스가 계속 발생하기 때문에 메인 메모리에서 데이터를 계속 읽어와야 한다. 메인 메모리의 CPU에 비해 현저히 느려서, 메인 메모리로부터 데이터를 읽어오는 동안 CPU가 대기하게 되므로 비효율적으로 CPU를 사용하게 된다.

## 3. CPU 캐시는 지역성에 근거하여 데이터를 저장한다.
- 속도 : CPU 레지스터 > CPU 캐시(L1, L2, L3) > 메인 메모리 > ...
  <img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/9eddc7af-3cbc-42d8-87a3-46833ee9e13c" />


CPU 캐시에는 프로세스가 자주 사용하는 데이터가 저장되는데, 자주 사용한다의 판단은 지역성에 근거한다.
<img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/caa36ef3-2635-4aca-9408-cb3a48c2516e" />

- 시간 지역성 : 최근에 사용한 데이터에 다시 접근하는 경향
  ```java
  int[] arr = new int[10];
  
  int num = 1;
  for(int i = 0; i < 100; i++) {
    arr[0] = num++;
  }
  ```
- 공간 지역성 : 최근에 접근한 데이터의 주변 데이터에도 접근하는 경향
  ```java
  int[] arr = new int[10];

  for(int i = 0; i < 100; i++) {
    arr[i] = i;
  }
  ```
