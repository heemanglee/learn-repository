## 1. PCB(Process Control Block)란?
<img width="648" alt="스크린샷 2025-01-17 오후 4 43 21" src="https://github.com/user-attachments/assets/47459080-71b6-4c01-9e6e-01bed36c2a4b" />

프로세스가 생성될 때마다 PCB도 같이 생성된다. 즉, 프로세스마다 PCB가 존재한다.

PCB는 프로세스의 Metadata를 담고 있는 공간이다. PCB에 저장되는 데이터는 다음과 같다.
- PID(Process ID)
- 프로세스 상태(New, Ready, Running, Blocked, Terminiated)
- 프로세스의 우선순위
- CPU Register : 프로세스가 계산한 데이터를 담는 공간
- CPU PC : 다음에 실행할 명령어의 메모리 주소
- ...

## 2. Context Switching(문맥 교환)
<img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/59e18fc2-434e-4398-8d9f-40056757489f" />

Running 상태에 있던 프로세스가 CPU Time Quantum이 만료되어 타이머 인터럽트에 의해 Ready 상태가 되거나, 입출력 I/O에 의해 Blocked 상태가 될 때 사용하던 CPU를 반납한다. 이 CPU는 스케줄링에 의해 Ready Queue에서 대기 중인 다른 프로세스에게 할당된다. 

CPU를 사용하는 프로세스가 바뀔 때 컨텍스트 스위칭(Conext Switching)이 발생한다. 컨텍스트 스위칭은 현재 프로세스의 작업 내용을 PCB에 저장하고 다음으로 실행할 프로세스의 PCB 정보를 불러오는 과정이다. 프로세스의 작업 내용을 PCB에 저장하기 때문에, Ready Queue에서 대기하다가 다시 CPU를 할당받아 실행될 때 마지막으로 수행했던 작업을 이어서 진행할 수 있다.
(참고로 프로세스뿐만 아니라 스레드에서도 컨텍스트 스위칭이 발생한다.)

우리가 수많은 프로그램을 실행할 때 동시에 실행되는 것처럼 보이는 이유는 컨텍스트 스위칭이 발생하기 때문이다. CPU 자원은 한정적이지만 실행되는 프로그램은 매우 많다. 모든 프로그램이 실시간으로 동시에 실행되는 것처럼 보이는 이유는 컨텍스트 스위칭 속도가 매우 빠르기 때문이다.

그러나 컨텍스트 스위칭이 빈번히 일어나면 성능상 좋지 않다. 컨텍스트 스위칭이 발생하면 CPU 캐시 무효화가 발생하기 때문이다. CPU는 프로세스가 사용할 데이터를 메인 메모리(RAM)에서 받아오는데, 메인 메모리의 속도는 CPU보다 현저히 느리다. 따라서 CPU 내부에 캐시 메모리를 사용하여 매번 메인 메모리에서 데이터를 받아오지 않고, 프로세스가 반복적으로 사용하는 데이터는 CPU 캐시에 저장하여 빠르게 접근할 수 있도록 한다. 

CPU 캐시에는 현재 프로세스가 사용 중인 데이터가 저장되므로, 컨텍스트 스위칭이 발생하면 CPU 캐시에 담긴 데이터를 사용할 수 없다. 따라서 컨텍스트 스위칭이 발생하면 CPU 캐시에 저장된 데이터를 무효화해야 한다. CPU를 새로 할당받은 프로세스는 CPU 캐시에 저장된 데이터가 없으므로 초반에 캐시 미스가 계속 발생하여 메인 메모리에서 데이터를 읽어와야 한다. 점차 CPU 캐시에 데이터가 쌓이면서 캐시 히트도 빈번히 일어나겠지만, 그전에는 캐시 미스로 인해 속도가 느린 메인 메모리에 접근해야 하므로 CPU 효율이 좋지 않다.

## 3. CPU 캐시는 지역성에 근거하여 데이터를 저장한다.
- 속도 : CPU 레지스터 > CPU 캐시(L1, L2, L3) > 메인 메모리 > ...
  <img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/9eddc7af-3cbc-42d8-87a3-46833ee9e13c" />


CPU 캐시에는 프로세스가 자주 사용하는 데이터가 저장되는데, 자주 사용한다의 판단은 지역성에 근거한다.
<img width="680" alt="스크린샷 2025-01-17 오후 4 43 33" src="https://github.com/user-attachments/assets/caa36ef3-2635-4aca-9408-cb3a48c2516e" />

- 시간 지역성 : 최근에 사용한 데이터에 다시 접근하는 경향
  ```java
  int[] arr = new int[10];
  
  int num = 1;
  for(int i = 0; i < 100; i++) {
    arr[0] = num++;
  }
  ```
- 공간 지역성 : 최근에 접근한 데이터의 주변 데이터에도 접근하는 경향
  ```java
  int[] arr = new int[10];

  for(int i = 0; i < 100; i++) {
    arr[i] = i;
  }
  ```
